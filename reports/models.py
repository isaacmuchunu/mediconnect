from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django.core.validators import MinValueValidator, MaxValueValidator
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from django.conf import settings
import json
from datetime import datetime, timedelta

class BaseModel(models.Model):
    """Base model with common fields"""
    created_at = models.DateTimeField(_('Created At'), auto_now_add=True)
    updated_at = models.DateTimeField(_('Updated At'), auto_now=True)
    is_active = models.BooleanField(_('Active'), default=True)
    
    class Meta:
        abstract = True

class ReportTemplate(BaseModel):
    """Templates for different types of reports"""
    
    REPORT_TYPES = [
        ('referral_analytics', _('Referral Analytics')),
        ('appointment_analytics', _('Appointment Analytics')),
        ('patient_demographics', _('Patient Demographics')),
        ('doctor_performance', _('Doctor Performance')),
        ('system_usage', _('System Usage')),
        ('compliance', _('Compliance Report')),
        ('financial', _('Financial Report')),
        ('quality_metrics', _('Quality Metrics')),
        ('wait_times', _('Wait Times Analysis')),
        ('custom', _('Custom Report'))
    ]
    
    FREQUENCY_CHOICES = [
        ('daily', _('Daily')),
        ('weekly', _('Weekly')),
        ('monthly', _('Monthly')),
        ('quarterly', _('Quarterly')),
        ('yearly', _('Yearly')),
        ('on_demand', _('On Demand'))
    ]
    
    name = models.CharField(max_length=200, verbose_name=_('Name'))
    report_type = models.CharField(max_length=50, choices=REPORT_TYPES, verbose_name=_('Report Type'))
    category = models.ForeignKey('ReportCategory', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=_('Category'))
    description = models.TextField(blank=True, verbose_name=_('Description'))
    query_template = models.TextField(help_text=_('SQL query template for the report'), verbose_name=_('Query Template'))
    parameters = models.JSONField(default=dict, help_text=_('Report parameters and filters'), verbose_name=_('Parameters'))
    frequency = models.CharField(max_length=20, choices=FREQUENCY_CHOICES, default='on_demand', verbose_name=_('Frequency'))
    auto_generate = models.BooleanField(default=False, verbose_name=_('Auto Generate'))
    recipients = models.ManyToManyField(settings.AUTH_USER_MODEL, blank=True, help_text=_('Users who receive this report automatically'), verbose_name=_('Recipients'))
    
    class Meta:
        verbose_name = _('Report Template')
        verbose_name_plural = _('Report Templates')
        ordering = ['name']
    
    def __str__(self):
        return f'{self.name} ({self.get_report_type_display()})'

class Report(BaseModel):
    """Generated reports"""
    
    STATUS_CHOICES = [
        ('pending', _('Pending')),
        ('generating', _('Generating')),
        ('completed', _('Completed')),
        ('failed', _('Failed')),
        ('cancelled', _('Cancelled'))
    ]
    
    FORMAT_CHOICES = [
        ('html', _('HTML')),
        ('pdf', _('PDF')),
        ('excel', _('Excel')),
        ('csv', _('CSV')),
        ('json', _('JSON'))
    ]
    
    title = models.CharField(max_length=255, verbose_name=_('Title'))
    template = models.ForeignKey(ReportTemplate, on_delete=models.CASCADE, null=True, blank=True, verbose_name=_('Template'))
    category = models.ForeignKey('ReportCategory', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=_('Category'))
    # Fixed: Added null=True and blank=True to make field nullable temporarily
    # You can create a data migration to populate existing rows, then remove null=True
    generated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE, 
        related_name='generated_reports',
        null=True,  # Allow null for existing rows
        blank=True,  # Allow blank in forms
        verbose_name=_('Generated By')
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name=_('Status'))
    format = models.CharField(max_length=10, choices=FORMAT_CHOICES, default='html', verbose_name=_('Format'))
    
    # Report parameters and filters
    parameters = models.JSONField(default=dict, verbose_name=_('Parameters'))
    date_from = models.DateField(null=True, blank=True, verbose_name=_('Date From'))
    date_to = models.DateField(null=True, blank=True, verbose_name=_('Date To'))
    
    # Report content and metadata
    content = models.TextField(blank=True, verbose_name=_('Content'))
    file_path = models.FileField(upload_to='reports/', null=True, blank=True, verbose_name=_('File Path'))
    summary = models.JSONField(default=dict, help_text=_('Report summary statistics'), verbose_name=_('Summary'))
    
    # Processing information - Using created_at instead of generated_at
    # created_at is inherited from BaseModel and represents when report was generated
    started_at = models.DateTimeField(null=True, blank=True, verbose_name=_('Started At'))
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name=_('Completed At'))
    error_message = models.TextField(blank=True, verbose_name=_('Error Message'))
    processing_time = models.DurationField(null=True, blank=True, verbose_name=_('Processing Time'))
    
    # Access control
    is_public = models.BooleanField(default=False, verbose_name=_('Is Public'))
    shared_with = models.ManyToManyField(settings.AUTH_USER_MODEL, blank=True, related_name='shared_reports', verbose_name=_('Shared With'))
    
    class Meta:
        verbose_name = _('Report')
        verbose_name_plural = _('Reports')
        ordering = ['-created_at']
        permissions = [
            ('can_view_all_reports', 'Can view all reports'),
            ('can_generate_reports', 'Can generate reports'),
            ('can_schedule_reports', 'Can schedule reports'),
        ]
    
    def __str__(self):
        return f'{self.title} - {self.created_at.strftime("%Y-%m-%d")}'
    
    @property
    def is_completed(self):
        return self.status == 'completed'
    
    @property
    def is_failed(self):
        return self.status == 'failed'
    
    @property 
    def generated_at(self):
        """Alias for created_at for backwards compatibility"""
        return self.created_at
    
    def mark_as_started(self):
        self.status = 'generating'
        self.started_at = timezone.now()
        self.save()
    
    def mark_as_completed(self, content=None, file_path=None, summary=None):
        self.status = 'completed'
        self.completed_at = timezone.now()
        if self.started_at:
            self.processing_time = self.completed_at - self.started_at
        if content:
            self.content = content
        if file_path:
            self.file_path = file_path
        if summary:
            self.summary = summary
        self.save()
    
    def mark_as_failed(self, error_message):
        self.status = 'failed'
        self.error_message = error_message
        self.completed_at = timezone.now()
        self.save()

class ReferralAnalytics(BaseModel):
    """Analytics data for referrals"""
    
    # Time period
    date = models.DateField(verbose_name=_('Date'))
    period_type = models.CharField(max_length=20, choices=[
        ('daily', _('Daily')),
        ('weekly', _('Weekly')),
        ('monthly', _('Monthly'))
    ], verbose_name=_('Period Type'))
    
    # Referral metrics
    total_referrals = models.IntegerField(default=0, verbose_name=_('Total Referrals'))
    pending_referrals = models.IntegerField(default=0, verbose_name=_('Pending Referrals'))
    accepted_referrals = models.IntegerField(default=0, verbose_name=_('Accepted Referrals'))
    rejected_referrals = models.IntegerField(default=0, verbose_name=_('Rejected Referrals'))
    completed_referrals = models.IntegerField(default=0, verbose_name=_('Completed Referrals'))
    
    # Time metrics
    avg_response_time = models.DurationField(null=True, blank=True, verbose_name=_('Average Response Time'))
    avg_completion_time = models.DurationField(null=True, blank=True, verbose_name=_('Average Completion Time'))
    
    # Department/specialty breakdown
    specialty_breakdown = models.JSONField(default=dict, verbose_name=_('Specialty Breakdown'))
    
    # Quality metrics
    acceptance_rate = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        default=0.0,
        verbose_name=_('Acceptance Rate')
    )
    completion_rate = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        default=0.0,
        verbose_name=_('Completion Rate')
    )
    
    class Meta:
        verbose_name = _('Referral Analytics')
        verbose_name_plural = _('Referral Analytics')
        unique_together = ['date', 'period_type']
        ordering = ['-date']
    
    def __str__(self):
        return f'Referral Analytics - {self.date} ({self.period_type})'

class AppointmentAnalytics(BaseModel):
    """Analytics data for appointments"""
    
    # Time period
    date = models.DateField(verbose_name=_('Date'))
    period_type = models.CharField(max_length=20, choices=[
        ('daily', _('Daily')),
        ('weekly', _('Weekly')),
        ('monthly', _('Monthly'))
    ], verbose_name=_('Period Type'))
    
    # Appointment metrics
    total_appointments = models.IntegerField(default=0, verbose_name=_('Total Appointments'))
    scheduled_appointments = models.IntegerField(default=0, verbose_name=_('Scheduled Appointments'))
    completed_appointments = models.IntegerField(default=0, verbose_name=_('Completed Appointments'))
    cancelled_appointments = models.IntegerField(default=0, verbose_name=_('Cancelled Appointments'))
    no_show_appointments = models.IntegerField(default=0, verbose_name=_('No Show Appointments'))
    
    # Time metrics
    avg_wait_time = models.DurationField(null=True, blank=True, verbose_name=_('Average Wait Time'))
    avg_appointment_duration = models.DurationField(null=True, blank=True, verbose_name=_('Average Appointment Duration'))
    
    # Utilization metrics
    utilization_rate = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        default=0.0,
        verbose_name=_('Utilization Rate')
    )
    no_show_rate = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        default=0.0,
        verbose_name=_('No Show Rate')
    )
    
    class Meta:
        verbose_name = _('Appointment Analytics')
        verbose_name_plural = _('Appointment Analytics')
        unique_together = ['date', 'period_type']
        ordering = ['-date']
    
    def __str__(self):
        return f'Appointment Analytics - {self.date} ({self.period_type})'

class SystemUsageAnalytics(BaseModel):
    """System usage analytics"""
    
    # Time period
    date = models.DateField(verbose_name=_('Date'))
    hour = models.IntegerField(null=True, blank=True, validators=[
        MinValueValidator(0), MaxValueValidator(23)
    ], verbose_name=_('Hour'))
    
    # User metrics
    total_users = models.IntegerField(default=0, verbose_name=_('Total Users'))
    active_users = models.IntegerField(default=0, verbose_name=_('Active Users'))
    new_users = models.IntegerField(default=0, verbose_name=_('New Users'))
    
    # Session metrics
    total_sessions = models.IntegerField(default=0, verbose_name=_('Total Sessions'))
    avg_session_duration = models.DurationField(null=True, blank=True, verbose_name=_('Average Session Duration'))
    
    # Page views and actions
    page_views = models.IntegerField(default=0, verbose_name=_('Page Views'))
    unique_page_views = models.IntegerField(default=0, verbose_name=_('Unique Page Views'))
    
    # Feature usage
    feature_usage = models.JSONField(default=dict, verbose_name=_('Feature Usage'))
    
    # Performance metrics
    avg_response_time = models.FloatField(default=0.0, verbose_name=_('Average Response Time'))
    error_rate = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        default=0.0,
        verbose_name=_('Error Rate')
    )
    
    class Meta:
        verbose_name = _('System Usage Analytics')
        verbose_name_plural = _('System Usage Analytics')
        unique_together = ['date', 'hour']
        ordering = ['-date', '-hour']
    
    def __str__(self):
        if self.hour is not None:
            return f'System Usage - {self.date} {self.hour}:00'
        return f'System Usage - {self.date}'

class ComplianceReport(BaseModel):
    """Compliance and audit reports"""
    
    COMPLIANCE_TYPES = [
        ('hipaa', _('HIPAA Compliance')),
        ('gdpr', _('GDPR Compliance')),
        ('audit_trail', _('Audit Trail')),
        ('data_access', _('Data Access Log')),
        ('security', _('Security Report')),
        ('quality', _('Quality Assurance'))
    ]
    
    report_type = models.CharField(max_length=50, choices=COMPLIANCE_TYPES, verbose_name=_('Report Type'))
    period_start = models.DateTimeField(verbose_name=_('Period Start'))
    period_end = models.DateTimeField(verbose_name=_('Period End'))
    
    # Compliance metrics
    total_events = models.IntegerField(default=0, verbose_name=_('Total Events'))
    compliant_events = models.IntegerField(default=0, verbose_name=_('Compliant Events'))
    non_compliant_events = models.IntegerField(default=0, verbose_name=_('Non-Compliant Events'))
    
    # Detailed findings
    findings = models.JSONField(default=list, verbose_name=_('Findings'))
    recommendations = models.JSONField(default=list, verbose_name=_('Recommendations'))
    
    # Risk assessment
    risk_level = models.CharField(max_length=20, choices=[
        ('low', _('Low')),
        ('medium', _('Medium')),
        ('high', _('High')),
        ('critical', _('Critical'))
    ], default='low', verbose_name=_('Risk Level'))
    
    # Compliance score
    compliance_score = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        default=100.0,
        verbose_name=_('Compliance Score')
    )
    
    # Report metadata - Fixed similar issue
    generated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE,
        null=True,  # Allow null for existing rows
        blank=True,  # Allow blank in forms
        verbose_name=_('Generated By')
    )
    reviewed_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='reviewed_compliance_reports',
        verbose_name=_('Reviewed By')
    )
    reviewed_at = models.DateTimeField(null=True, blank=True, verbose_name=_('Reviewed At'))
    
    class Meta:
        verbose_name = _('Compliance Report')
        verbose_name_plural = _('Compliance Reports')
        ordering = ['-created_at']
    
    def __str__(self):
        return f'{self.get_report_type_display()} - {self.period_start.date()} to {self.period_end.date()}'
    
    @property
    def compliance_percentage(self):
        if self.total_events == 0:
            return 100.0
        return (self.compliant_events / self.total_events) * 100

class ReportSchedule(BaseModel):
    """Scheduled report generation"""
    
    template = models.ForeignKey(ReportTemplate, on_delete=models.CASCADE, verbose_name=_('Template'))
    name = models.CharField(max_length=200, verbose_name=_('Name'))
    
    # Schedule settings
    frequency = models.CharField(max_length=20, choices=ReportTemplate.FREQUENCY_CHOICES, verbose_name=_('Frequency'))
    day_of_week = models.IntegerField(
        null=True, blank=True,
        validators=[MinValueValidator(0), MaxValueValidator(6)],
        help_text=_('0=Monday, 6=Sunday'),
        verbose_name=_('Day of Week')
    )
    day_of_month = models.IntegerField(
        null=True, blank=True,
        validators=[MinValueValidator(1), MaxValueValidator(31)],
        verbose_name=_('Day of Month')
    )
    time_of_day = models.TimeField(default='09:00', verbose_name=_('Time of Day'))
    
    # Recipients
    recipients = models.ManyToManyField(settings.AUTH_USER_MODEL, help_text=_('Users who will receive the scheduled report'), verbose_name=_('Recipients'))
    
    # Status
    is_enabled = models.BooleanField(default=True, verbose_name=_('Is Enabled'))
    last_run = models.DateTimeField(null=True, blank=True, verbose_name=_('Last Run'))
    next_run = models.DateTimeField(null=True, blank=True, verbose_name=_('Next Run'))
    
    # Parameters
    default_parameters = models.JSONField(default=dict, verbose_name=_('Default Parameters'))
    
    class Meta:
        verbose_name = _('Report Schedule')
        verbose_name_plural = _('Report Schedules')
        ordering = ['name']
    
    def __str__(self):
        return f'{self.name} ({self.get_frequency_display()})'
    
    def calculate_next_run(self):
        """Calculate the next run time based on frequency"""
        now = timezone.now()
        
        if self.frequency == 'daily':
            next_run = now.replace(hour=self.time_of_day.hour, minute=self.time_of_day.minute, second=0, microsecond=0)
            if next_run <= now:
                next_run += timedelta(days=1)
        
        elif self.frequency == 'weekly' and self.day_of_week is not None:
            days_ahead = self.day_of_week - now.weekday()
            if days_ahead <= 0:
                days_ahead += 7
            next_run = now + timedelta(days=days_ahead)
            next_run = next_run.replace(hour=self.time_of_day.hour, minute=self.time_of_day.minute, second=0, microsecond=0)
        
        elif self.frequency == 'monthly' and self.day_of_month is not None:
            if now.day < self.day_of_month:
                next_run = now.replace(day=self.day_of_month, hour=self.time_of_day.hour, minute=self.time_of_day.minute, second=0, microsecond=0)
            else:
                # Next month
                if now.month == 12:
                    next_run = now.replace(year=now.year + 1, month=1, day=self.day_of_month, hour=self.time_of_day.hour, minute=self.time_of_day.minute, second=0, microsecond=0)
                else:
                    next_run = now.replace(month=now.month + 1, day=self.day_of_month, hour=self.time_of_day.hour, minute=self.time_of_day.minute, second=0, microsecond=0)
        
        else:
            next_run = None
        
        self.next_run = next_run
        self.save()
        return next_run

class ReportAccess(BaseModel):
    """Track report access for audit purposes"""
    
    report = models.ForeignKey(Report, on_delete=models.CASCADE, related_name='access_logs', verbose_name=_('Report'))
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, verbose_name=_('User'))
    accessed_at = models.DateTimeField(auto_now_add=True, verbose_name=_('Accessed At'))
    ip_address = models.GenericIPAddressField(null=True, blank=True, verbose_name=_('IP Address'))
    user_agent = models.TextField(blank=True, verbose_name=_('User Agent'))
    action = models.CharField(max_length=50, choices=[
        ('view', _('Viewed')),
        ('download', _('Downloaded')),
        ('share', _('Shared')),
        ('export', _('Exported'))
    ], verbose_name=_('Action'))
    
    class Meta:
        verbose_name = _('Report Access')
        verbose_name_plural = _('Report Access Logs')
        ordering = ['-accessed_at']
    
    def __str__(self):
        return f'{self.user.username} {self.action} {self.report.title} at {self.accessed_at}'


class ReportCategory(BaseModel):
    """Categorize reports for better organization"""
    
    name = models.CharField(max_length=100, unique=True, verbose_name=_('Name'))
    description = models.TextField(blank=True, verbose_name=_('Description'))
    color = models.CharField(max_length=7, default='#007bff', help_text=_('Hex color code'), verbose_name=_('Color'))
    icon = models.CharField(max_length=50, blank=True, help_text=_('CSS icon class'), verbose_name=_('Icon'))
    parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True, related_name='subcategories', verbose_name=_('Parent Category'))
    sort_order = models.IntegerField(default=0, verbose_name=_('Sort Order'))
    
    class Meta:
        verbose_name = _('Report Category')
        verbose_name_plural = _('Report Categories')
        ordering = ['sort_order', 'name']
    
    def __str__(self):
        if self.parent:
            return f'{self.parent.name} > {self.name}'
        return self.name
    
    @property
    def full_path(self):
        """Get the full category path"""
        if self.parent:
            return f'{self.parent.full_path} > {self.name}'
        return self.name


class ReportFilter(BaseModel):
    """Saved filters for reports"""
    
    FILTER_TYPES = [
        ('date_range', _('Date Range')),
        ('user_filter', _('User Filter')),
        ('department', _('Department')),
        ('specialty', _('Specialty')),
        ('status', _('Status')),
        ('priority', _('Priority')),
        ('custom', _('Custom Filter'))
    ]
    
    name = models.CharField(max_length=100, verbose_name=_('Name'))
    description = models.TextField(blank=True, verbose_name=_('Description'))
    filter_type = models.CharField(max_length=20, choices=FILTER_TYPES, verbose_name=_('Filter Type'))
    filter_config = models.JSONField(default=dict, help_text=_('Filter configuration and parameters'), verbose_name=_('Filter Configuration'))
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='created_filters', verbose_name=_('Created By'))
    is_public = models.BooleanField(default=False, verbose_name=_('Is Public'))
    shared_with = models.ManyToManyField(settings.AUTH_USER_MODEL, blank=True, related_name='shared_filters', verbose_name=_('Shared With'))
    usage_count = models.IntegerField(default=0, verbose_name=_('Usage Count'))
    
    class Meta:
        verbose_name = _('Report Filter')
        verbose_name_plural = _('Report Filters')
        ordering = ['-usage_count', 'name']
    
    def __str__(self):
        return f'{self.name} ({self.get_filter_type_display()})'
    
    def increment_usage(self):
        """Increment usage counter"""
        self.usage_count += 1
        self.save(update_fields=['usage_count'])


class ReportExport(BaseModel):
    """Track report exports and downloads"""
    
    EXPORT_FORMATS = [
        ('pdf', _('PDF')),
        ('excel', _('Excel')),
        ('csv', _('CSV')),
        ('json', _('JSON')),
        ('xml', _('XML')),
        ('word', _('Word Document'))
    ]
    
    EXPORT_STATUS = [
        ('pending', _('Pending')),
        ('processing', _('Processing')),
        ('completed', _('Completed')),
        ('failed', _('Failed')),
        ('expired', _('Expired'))
    ]
    
    report = models.ForeignKey(Report, on_delete=models.CASCADE, related_name='exports', verbose_name=_('Report'))
    exported_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, verbose_name=_('Exported By'))
    export_format = models.CharField(max_length=10, choices=EXPORT_FORMATS, verbose_name=_('Export Format'))
    status = models.CharField(max_length=20, choices=EXPORT_STATUS, default='pending', verbose_name=_('Status'))
    file_path = models.FileField(upload_to='exports/', null=True, blank=True, verbose_name=_('File Path'))
    file_size = models.BigIntegerField(null=True, blank=True, verbose_name=_('File Size'))
    download_count = models.IntegerField(default=0, verbose_name=_('Download Count'))
    expires_at = models.DateTimeField(null=True, blank=True, verbose_name=_('Expires At'))
    export_parameters = models.JSONField(default=dict, verbose_name=_('Export Parameters'))
    processing_time = models.DurationField(null=True, blank=True, verbose_name=_('Processing Time'))
    error_message = models.TextField(blank=True, verbose_name=_('Error Message'))
    
    class Meta:
        verbose_name = _('Report Export')
        verbose_name_plural = _('Report Exports')
        ordering = ['-created_at']
    
    def __str__(self):
        return f'{self.report.title} - {self.get_export_format_display()} ({self.status})'
    
    @property
    def is_expired(self):
        """Check if export has expired"""
        if self.expires_at:
            return timezone.now() > self.expires_at
        return False
    
    def increment_download(self):
        """Increment download counter"""
        self.download_count += 1
        self.save(update_fields=['download_count'])


class ReportShare(BaseModel):
    """Share reports with users or external parties"""
    
    SHARE_TYPES = [
        ('internal', _('Internal User')),
        ('external', _('External Email')),
        ('public_link', _('Public Link')),
        ('department', _('Department')),
        ('role', _('Role-based'))
    ]
    
    PERMISSION_LEVELS = [
        ('view', _('View Only')),
        ('download', _('View and Download')),
        ('comment', _('View, Download and Comment')),
        ('edit', _('Full Access'))
    ]
    
    report = models.ForeignKey(Report, on_delete=models.CASCADE, related_name='shares', verbose_name=_('Report'))
    shared_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='shared_reports_by', verbose_name=_('Shared By'))
    share_type = models.CharField(max_length=20, choices=SHARE_TYPES, verbose_name=_('Share Type'))
    permission_level = models.CharField(max_length=20, choices=PERMISSION_LEVELS, default='view', verbose_name=_('Permission Level'))
    
    # Internal sharing
    shared_with_user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, null=True, blank=True, related_name='received_report_shares', verbose_name=_('Shared With User'))
    
    # External sharing
    external_email = models.EmailField(blank=True, verbose_name=_('External Email'))
    external_name = models.CharField(max_length=100, blank=True, verbose_name=_('External Name'))
    
    # Public link sharing
    share_token = models.CharField(max_length=64, unique=True, null=True, blank=True, verbose_name=_('Share Token'))
    expires_at = models.DateTimeField(null=True, blank=True, verbose_name=_('Expires At'))
    access_count = models.IntegerField(default=0, verbose_name=_('Access Count'))
    max_access_count = models.IntegerField(null=True, blank=True, verbose_name=_('Max Access Count'))
    
    # Additional settings
    message = models.TextField(blank=True, verbose_name=_('Message'))
    is_active = models.BooleanField(default=True, verbose_name=_('Is Active'))
    notify_on_access = models.BooleanField(default=False, verbose_name=_('Notify on Access'))
    
    class Meta:
        verbose_name = _('Report Share')
        verbose_name_plural = _('Report Shares')
        ordering = ['-created_at']
    
    def __str__(self):
        if self.shared_with_user:
            return f'{self.report.title} shared with {self.shared_with_user.username}'
        elif self.external_email:
            return f'{self.report.title} shared with {self.external_email}'
        else:
            return f'{self.report.title} - {self.get_share_type_display()}'
    
    @property
    def is_expired(self):
        """Check if share has expired"""
        if self.expires_at:
            return timezone.now() > self.expires_at
        if self.max_access_count and self.access_count >= self.max_access_count:
            return True
        return False
    
    def increment_access(self):
        """Increment access counter"""
        self.access_count += 1
        self.save(update_fields=['access_count'])


class ReportComment(BaseModel):
    """Comments and annotations on reports"""
    
    COMMENT_TYPES = [
        ('general', _('General Comment')),
        ('question', _('Question')),
        ('suggestion', _('Suggestion')),
        ('issue', _('Issue')),
        ('approval', _('Approval')),
        ('rejection', _('Rejection'))
    ]
    
    report = models.ForeignKey(Report, on_delete=models.CASCADE, related_name='comments', verbose_name=_('Report'))
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, verbose_name=_('Author'))
    comment_type = models.CharField(max_length=20, choices=COMMENT_TYPES, default='general', verbose_name=_('Comment Type'))
    content = models.TextField(verbose_name=_('Content'))
    parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True, related_name='replies', verbose_name=_('Parent Comment'))
    
    # Annotations
    page_number = models.IntegerField(null=True, blank=True, verbose_name=_('Page Number'))
    position_x = models.FloatField(null=True, blank=True, verbose_name=_('Position X'))
    position_y = models.FloatField(null=True, blank=True, verbose_name=_('Position Y'))
    highlighted_text = models.TextField(blank=True, verbose_name=_('Highlighted Text'))
    
    # Status
    is_resolved = models.BooleanField(default=False, verbose_name=_('Is Resolved'))
    resolved_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True, related_name='resolved_comments', verbose_name=_('Resolved By'))
    resolved_at = models.DateTimeField(null=True, blank=True, verbose_name=_('Resolved At'))
    
    # Metadata
    is_private = models.BooleanField(default=False, verbose_name=_('Is Private'))
    attachments = models.JSONField(default=list, verbose_name=_('Attachments'))
    
    class Meta:
        verbose_name = _('Report Comment')
        verbose_name_plural = _('Report Comments')
        ordering = ['created_at']
    
    def __str__(self):
        return f'Comment by {self.author.username} on {self.report.title}'
    
    def mark_resolved(self, resolved_by):
        """Mark comment as resolved"""
        self.is_resolved = True
        self.resolved_by = resolved_by
        self.resolved_at = timezone.now()
        self.save()
    
    @property
    def reply_count(self):
        """Get number of replies"""
        return self.replies.count()